import * as i0 from '@angular/core';
import { Injectable } from '@angular/core';
import { webSocket } from 'rxjs/webSocket';
import { Subject } from 'rxjs';
import { take, filter, pluck, map, tap } from 'rxjs/operators';

class NgxRoslibService {
    constructor() {
        this.isConnected = false;
    }
    set statusLevel(level) {
        if (this.ros)
            this.ros.statusLevel = level;
    }
    connect(url, transportLibrary = 'websocket', transportOptions) {
        const ros = (this.ros = new Rosbridge());
        this.connection$ = ros.connect(url, transportLibrary, transportOptions);
        this.onOpen = ros.onOpen;
        this.onClose = ros.onClose;
        this.onError = ros.onError;
        return ros;
    }
    ngOnDestroy() {
        var _a;
        (_a = this.connection$) === null || _a === void 0 ? void 0 : _a.complete();
    }
}
NgxRoslibService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.1", ngImport: i0, type: NgxRoslibService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NgxRoslibService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.1", ngImport: i0, type: NgxRoslibService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.1", ngImport: i0, type: NgxRoslibService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });
class Rosbridge {
    constructor(url, transportLibrary, transportOptions) {
        this.isConnected = false;
        this.transportLibrary = 'websocket';
        this.connectionOpened$ = new Subject();
        this.onOpen = this.connectionOpened$.asObservable();
        this.connectionClosed$ = new Subject();
        this.onClose = this.connectionClosed$.asObservable();
        this.connectionError$ = new Subject();
        this.onError = this.connectionError$.asObservable();
        if (url) {
            this.connection$ = this.connect(url, transportLibrary !== null && transportLibrary !== void 0 ? transportLibrary : 'websocket', transportOptions);
        }
    }
    set statusLevel(level) {
        const setStateLevelRequest = new SetStatusLevel(level);
        this.sendRequest(setStateLevelRequest);
    }
    connect(url, transportLibrary = 'websocket', transportOptions) {
        var _a;
        this.transportOptions = transportOptions;
        this.transportLibrary = transportLibrary;
        let wsUrl;
        if (transportLibrary === 'websocket') {
            wsUrl = url.replace(/(http)(s)?:\/\//, 'ws$2://');
            if (!this.connection$ || this.connection$.closed) {
                this.connection$ = webSocket({
                    url: wsUrl,
                    binaryType: 'arraybuffer',
                    openObserver: {
                        next: (value) => {
                            this.isConnected = true;
                            this.connectionOpened$.next(value);
                        },
                    },
                    closeObserver: {
                        next: (closeEvent) => {
                            this.isConnected = false;
                            this.connectionClosed$.next(closeEvent);
                        },
                    },
                    closingObserver: {
                        next: () => { },
                    },
                });
            }
        }
        else if (transportLibrary === 'workerSocket') {
            // TODO: add websocket in web worker implementation for the connect method
            //
        }
        (_a = this.connection$) === null || _a === void 0 ? void 0 : _a.subscribe(() => { }, () => { }); // Needed to open the websocket
        return this.connection$;
    }
    authenticate(mac, client, dest, rand, t, level, end) {
        this.sendRequest({
            op: 'auth',
            mac: mac,
            client: client,
            dest: dest,
            rand: rand,
            t: t,
            level: level,
            end: end,
        });
    }
    sendRequest(message) {
        var _a, _b;
        if (!this.isConnected) {
            console.log('Trying to send request, but not connected. Waiting...');
            (_a = this.onOpen) === null || _a === void 0 ? void 0 : _a.pipe(take(1)).subscribe(() => { var _a; return (_a = this.connection$) === null || _a === void 0 ? void 0 : _a.next(message); });
        }
        else {
            (_b = this.connection$) === null || _b === void 0 ? void 0 : _b.next(message);
        }
    }
    getTopics(callback, failedCallback) {
        const topicsService = new RosService({
            ros: this,
            name: '/rosapi/topics',
            serviceType: 'rosapi/Topics',
        });
        if (failedCallback) {
            topicsService.call({}, (msg) => {
                callback(msg.topics);
            }, failedCallback);
        }
        else {
            topicsService.call({}, (msg) => {
                callback(msg.topics);
            });
        }
    }
    getNodes(callback, failedCallback) {
        const topicsService = new RosService({
            ros: this,
            name: '/rosapi/nodes',
            serviceType: 'rosapi/Nodes',
        });
        if (failedCallback) {
            topicsService.call({}, (msg) => {
                callback(msg.nodes);
            }, failedCallback);
        }
        else {
            topicsService.call({}, (msg) => {
                callback(msg.nodes);
            });
        }
    }
}
let idCounter = 0;
class RosbridgeProtocol {
}
class SetStatusLevel extends RosbridgeProtocol {
    constructor(level, id) {
        super();
        this.op = 'set_level';
        this.level = level;
        this.id = id;
    }
}
class StatusMessage extends RosbridgeProtocol {
    constructor(level, msg, id) {
        super();
        this.op = 'status';
        this.level = level;
        this.id = id;
        this.msg = msg;
    }
}
class Authenticate extends RosbridgeProtocol {
    constructor(mac, client, dest, rand, t, level, end) {
        super();
        this.op = 'auth';
        this.mac = mac;
        this.client = client;
        this.dest = dest;
        this.rand = rand;
        this.t = t;
        this.level = level;
        this.end = end;
    }
}
class Advertise extends RosbridgeProtocol {
    constructor(topic, type, id, latch, queue_size) {
        super();
        this.op = 'advertise';
        this.topic = topic;
        this.id = `advertise:${this.topic}:${++idCounter}`;
        this.type = type;
        this.latch = latch !== null && latch !== void 0 ? latch : false;
        if (queue_size) {
            this.queue_size = Math.max(0, queue_size);
        }
        else {
            this.queue_size = 100;
        }
    }
}
class Unadvertise extends RosbridgeProtocol {
    constructor(topic, id) {
        super();
        this.op = 'unadvertise';
        this.id = id;
        this.topic = topic;
    }
}
class Publish extends RosbridgeProtocol {
    constructor(topic, msg, id, latch, queue_size) {
        super();
        this.op = 'publish';
        this.topic = topic;
        this.id = `publish:${this.topic}:${++idCounter}`;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.msg = msg;
        this.latch = latch !== null && latch !== void 0 ? latch : false;
        if (queue_size) {
            this.queue_size = Math.max(0, queue_size);
        }
        else {
            this.queue_size = 100;
        }
    }
}
class Subscribe extends RosbridgeProtocol {
    constructor(topic, type, throttle_rate, queue_length, fragment_size, compression, id) {
        super();
        this.op = 'subscribe';
        this.topic = topic;
        this.id = `subscribe:${this.topic}:${++idCounter}`;
        this.type = type;
        this.throttle_rate = throttle_rate !== null && throttle_rate !== void 0 ? throttle_rate : 0;
        this.queue_length = queue_length !== null && queue_length !== void 0 ? queue_length : 0;
        this.fragment_size = fragment_size;
        this.compression = compression !== null && compression !== void 0 ? compression : 'none';
    }
}
class ServiceCall extends RosbridgeProtocol {
    constructor(service, args, id, fragment_size, compression) {
        super();
        this.args = {};
        this.op = 'call_service';
        this.service = service;
        this.id = id !== null && id !== void 0 ? id : `call_service:${this.service}:${++idCounter}`;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.args = args !== null && args !== void 0 ? args : {};
        this.fragment_size = fragment_size;
        this.compression = compression;
    }
}
class AdvertiseService extends RosbridgeProtocol {
    constructor(type, service) {
        super();
        this.op = 'advertise_service';
        this.type = type;
        this.service = service;
    }
}
class UnadvertiseService extends RosbridgeProtocol {
    constructor(service) {
        super();
        this.op = 'unadvertise_service';
        this.service = service;
    }
}
class ServiceRequest extends RosbridgeProtocol {
}
class ServiceResponse extends RosbridgeProtocol {
    constructor(service, result, values, id) {
        super();
        this.op = 'service_response';
        this.id = id;
        this.service = service;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.values = values !== null && values !== void 0 ? values : {};
        this.result = result;
    }
}
class Unsubscribe extends RosbridgeProtocol {
    constructor(topic, id) {
        super();
        this.op = 'unsubscribe';
        this.topic = topic;
        this.id = id;
    }
}
/**
 * RosTopic class used to instantiate a topic, subscribe to its event and advertise future events regarding the topic
 */
class RosTopic {
    constructor({ ros, name, messageType, compression = 'none', throttleRate = 0, latch = false, queueSize = 100, queueLength = 0, reconnectOnClose = true, }) {
        this.ros = ros;
        this.name = name;
        this.messageType = messageType;
        this.compression = compression;
        this.throttleRate = throttleRate;
        this.latch = latch;
        this.queueSize = queueSize;
        this.queueLength = queueLength;
        this.reconnectOnClose = reconnectOnClose;
        this.throttleRate = Math.max(this.throttleRate, 0);
    }
    subscribe(callback) {
        var _a, _b;
        const subRequest = new Subscribe(this.name, this.messageType);
        this.observable$ = (_a = this.ros.connection$) === null || _a === void 0 ? void 0 : _a.pipe(filter((data) => (data === null || data === void 0 ? void 0 : data.topic) === this.name && (data === null || data === void 0 ? void 0 : data.op) === 'publish' // eslint-disable-line @typescript-eslint/no-unsafe-member-access
        ), pluck('msg'));
        this.sub = (_b = this.observable$) === null || _b === void 0 ? void 0 : _b.subscribe((message) => callback(message));
        this.id = subRequest.id;
        this.ros.sendRequest(subRequest);
    }
    unsubscribe() {
        var _a;
        const unsubRequest = new Unsubscribe(this.name, this.id);
        this.ros.sendRequest(unsubRequest);
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
    advertise() {
        const advertiseRequest = new Advertise(this.name, this.messageType, this.id, this.latch, this.queueSize);
        this.id = advertiseRequest.id;
        this.ros.sendRequest(advertiseRequest);
    }
    publish(msg) {
        const publishRequest = new Publish(this.name, msg, this.id, this.latch, this.queueSize);
        this.ros.sendRequest(publishRequest);
    }
    unadvertise() {
        const unadvertiseRequest = new Unadvertise(this.name, this.id);
        this.ros.sendRequest(unadvertiseRequest);
    }
}
class RosService {
    constructor({ ros, name, serviceType }) {
        this.isAdvertised = false;
        this.ros = ros;
        this.name = name;
        this.serviceType = serviceType;
    }
    advertise(callback) {
        var _a;
        const serviceAdvertiseRequest = new AdvertiseService(this.serviceType, this.name);
        (_a = this.ros.connection$) === null || _a === void 0 ? void 0 : _a.pipe(filter((data) => (data === null || data === void 0 ? void 0 : data.service) === this.name && // eslint-disable-line @typescript-eslint/no-unsafe-member-access
            (data === null || data === void 0 ? void 0 : data.op) === 'call_service' // eslint-disable-line @typescript-eslint/no-unsafe-member-access
        ), 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        map(({ args, id }) => ({ args, id }))).subscribe((req) => {
            var _a;
            const res = callback(req.args);
            const serviceResponse = new ServiceResponse(this.name, true, res, (_a = req.id) !== null && _a !== void 0 ? _a : '');
            this.ros.sendRequest(serviceResponse);
        });
        this.ros.sendRequest(serviceAdvertiseRequest);
        this.isAdvertised = true;
    }
    call(req, callback, failedCallback) {
        var _a;
        const serviceCallRequest = new ServiceCall(this.name, req);
        (_a = this.ros.connection$) === null || _a === void 0 ? void 0 : _a.pipe(filter((data) => (data === null || data === void 0 ? void 0 : data.service) === this.name && // eslint-disable-line @typescript-eslint/no-unsafe-member-access
            (data === null || data === void 0 ? void 0 : data.id) === serviceCallRequest.id && // eslint-disable-line @typescript-eslint/no-unsafe-member-access
            (data === null || data === void 0 ? void 0 : data.op) === 'service_response' // eslint-disable-line @typescript-eslint/no-unsafe-member-access
        ), tap((msg) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if ((msg === null || msg === void 0 ? void 0 : msg.result) !== undefined && (msg === null || msg === void 0 ? void 0 : msg.result) === false)
                if (failedCallback) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    failedCallback(msg.values);
                }
        }), 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        filter((data) => (data === null || data === void 0 ? void 0 : data.result) !== false), pluck('values'), take(1)).subscribe((message) => callback(message));
        this.ros.sendRequest(serviceCallRequest);
    }
    unadvertise() {
        if (!this.isAdvertised)
            return;
        const serviceUnadvertiseRequest = new UnadvertiseService(this.name);
        this.ros.sendRequest(serviceUnadvertiseRequest);
    }
}
class RosParam {
    constructor({ ros, name }) {
        this.ros = ros;
        this.name = name;
    }
    get(callback) {
        const paramService = new RosService({
            ros: this.ros,
            name: '/rosapi/get_param',
            serviceType: 'rosapi/GetParam',
        });
        paramService.call({ name: this.name }, (res) => {
            // @ts-ignore
            callback(JSON.parse(res.value));
        });
    }
    set(newValue, callback) {
        const paramService = new RosService({
            ros: this.ros,
            name: '/rosapi/set_param',
            serviceType: 'rosapi/SetParam',
        });
        paramService.call({ name: this.name, value: JSON.stringify(newValue) }, () => {
            callback();
        });
    }
    delete(callback) {
        const paramService = new RosService({
            ros: this.ros,
            name: '/rosapi/delete_param',
            serviceType: 'rosapi/DeleteParam',
        });
        paramService.call({ name: this.name }, () => {
            callback();
        });
    }
}

var RosoutLevel;
(function (RosoutLevel) {
    RosoutLevel[RosoutLevel["DEBUG"] = 1] = "DEBUG";
    RosoutLevel[RosoutLevel["INFO"] = 2] = "INFO";
    RosoutLevel[RosoutLevel["WARN"] = 4] = "WARN";
    RosoutLevel[RosoutLevel["ERROR"] = 8] = "ERROR";
    RosoutLevel[RosoutLevel["FATAL"] = 16] = "FATAL";
})(RosoutLevel || (RosoutLevel = {}));

/*
 * Public API Surface of ngx-roslib
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxRoslibService, RosParam, RosService, RosTopic, Rosbridge, RosoutLevel };
//# sourceMappingURL=ngx-roslib.js.map
